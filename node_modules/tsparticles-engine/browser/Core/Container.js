var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Container_engine, _Container_eventListeners, _Container_intersectionObserver, _Container_options, _Container_sourceOptions;
/**
 * [[include:Container.md]]
 * @packageDocumentation
 */
import { animate, cancelAnimation } from "../Utils/Utils";
import { Canvas } from "./Canvas";
import { EventListeners } from "./Utils/EventListeners";
import { FrameManager } from "./Utils/FrameManager";
import { Options } from "../Options/Classes/Options";
import { Particles } from "./Particles";
import { Retina } from "./Retina";
import { getRangeValue } from "../Utils/NumberUtils";
import { loadOptions } from "../Utils/OptionsUtils";
/**
 * Checks if the container is still usable
 * @param container the container to check
 * @returns true if the container is still usable
 */
function guardCheck(container) {
    return !container.destroyed;
}
function loadContainerOptions(engine, container, ...sourceOptionsArr) {
    const options = new Options(engine, container);
    loadOptions(options, ...sourceOptionsArr);
    return options;
}
const defaultPathGeneratorKey = "default", defaultPathGenerator = {
    generate: (p) => {
        const v = p.velocity.copy();
        v.angle += (v.length * Math.PI) / 180;
        return v;
    },
    init: () => {
        // nothing required
    },
    update: () => {
        // nothing required
    },
};
/**
 * The object loaded into an HTML element, it'll contain options loaded and all data to let everything working
 * [[include:Container.md]]
 * @category Core
 */
export class Container {
    /**
     * This is the core class, create an instance to have a new working particles manager
     * @constructor
     * @param engine the engine used by container
     * @param id the id to identify this instance
     * @param sourceOptions the options to load
     */
    constructor(engine, id, sourceOptions) {
        this.id = id;
        _Container_engine.set(this, void 0);
        _Container_eventListeners.set(this, void 0);
        _Container_intersectionObserver.set(this, void 0);
        _Container_options.set(this, void 0);
        _Container_sourceOptions.set(this, void 0);
        __classPrivateFieldSet(this, _Container_engine, engine, "f");
        this.fpsLimit = 120;
        this.duration = 0;
        this.lifeTime = 0;
        this.firstStart = true;
        this.started = false;
        this.destroyed = false;
        this.paused = true;
        this.lastFrameTime = 0;
        this.zLayers = 100;
        this.pageHidden = false;
        __classPrivateFieldSet(this, _Container_sourceOptions, sourceOptions, "f");
        this._initialSourceOptions = sourceOptions;
        this.retina = new Retina(this);
        this.canvas = new Canvas(this);
        this.particles = new Particles(__classPrivateFieldGet(this, _Container_engine, "f"), this);
        this.frameManager = new FrameManager(this);
        this.pathGenerators = new Map();
        this.interactivity = {
            mouse: {
                clicking: false,
                inside: false,
            },
        };
        this.plugins = new Map();
        this.drawers = new Map();
        /* tsParticles variables with default values */
        __classPrivateFieldSet(this, _Container_options, loadContainerOptions(__classPrivateFieldGet(this, _Container_engine, "f"), this), "f");
        this.actualOptions = loadContainerOptions(__classPrivateFieldGet(this, _Container_engine, "f"), this);
        /* ---------- tsParticles - start ------------ */
        __classPrivateFieldSet(this, _Container_eventListeners, new EventListeners(this), "f");
        if (typeof IntersectionObserver !== "undefined" && IntersectionObserver) {
            __classPrivateFieldSet(this, _Container_intersectionObserver, new IntersectionObserver((entries) => this.intersectionManager(entries)), "f");
        }
        __classPrivateFieldGet(this, _Container_engine, "f").dispatchEvent("containerBuilt" /* EventType.containerBuilt */, { container: this });
    }
    /**
     * The options used by the container, it's a full [[Options]] object
     */
    get options() {
        return __classPrivateFieldGet(this, _Container_options, "f");
    }
    /**
     * The options that were initially passed to the container
     */
    get sourceOptions() {
        return __classPrivateFieldGet(this, _Container_sourceOptions, "f");
    }
    /**
     * Adds a click handler to the container
     * @param callback the callback to be called when the click event occurs
     */
    addClickHandler(callback) {
        if (!guardCheck(this)) {
            return;
        }
        const el = this.interactivity.element;
        if (!el) {
            return;
        }
        const clickOrTouchHandler = (e, pos, radius) => {
            if (!guardCheck(this)) {
                return;
            }
            const pxRatio = this.retina.pixelRatio, posRetina = {
                x: pos.x * pxRatio,
                y: pos.y * pxRatio,
            }, particles = this.particles.quadTree.queryCircle(posRetina, radius * pxRatio);
            callback(e, particles);
        };
        const clickHandler = (e) => {
            if (!guardCheck(this)) {
                return;
            }
            const mouseEvent = e, pos = {
                x: mouseEvent.offsetX || mouseEvent.clientX,
                y: mouseEvent.offsetY || mouseEvent.clientY,
            };
            clickOrTouchHandler(e, pos, 1);
        };
        const touchStartHandler = () => {
            if (!guardCheck(this)) {
                return;
            }
            touched = true;
            touchMoved = false;
        };
        const touchMoveHandler = () => {
            if (!guardCheck(this)) {
                return;
            }
            touchMoved = true;
        };
        const touchEndHandler = (e) => {
            var _a, _b, _c;
            if (!guardCheck(this)) {
                return;
            }
            if (touched && !touchMoved) {
                const touchEvent = e;
                let lastTouch = touchEvent.touches[touchEvent.touches.length - 1];
                if (!lastTouch) {
                    lastTouch = touchEvent.changedTouches[touchEvent.changedTouches.length - 1];
                    if (!lastTouch) {
                        return;
                    }
                }
                const canvasRect = (_a = this.canvas.element) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect(), pos = {
                    x: lastTouch.clientX - ((_b = canvasRect === null || canvasRect === void 0 ? void 0 : canvasRect.left) !== null && _b !== void 0 ? _b : 0),
                    y: lastTouch.clientY - ((_c = canvasRect === null || canvasRect === void 0 ? void 0 : canvasRect.top) !== null && _c !== void 0 ? _c : 0),
                };
                clickOrTouchHandler(e, pos, Math.max(lastTouch.radiusX, lastTouch.radiusY));
            }
            touched = false;
            touchMoved = false;
        };
        const touchCancelHandler = () => {
            if (!guardCheck(this)) {
                return;
            }
            touched = false;
            touchMoved = false;
        };
        let touched = false;
        let touchMoved = false;
        el.addEventListener("click", clickHandler);
        el.addEventListener("touchstart", touchStartHandler);
        el.addEventListener("touchmove", touchMoveHandler);
        el.addEventListener("touchend", touchEndHandler);
        el.addEventListener("touchcancel", touchCancelHandler);
    }
    /**
     * Add a new path generator to the container
     * @param key the key to identify the path generator
     * @param generator the path generator
     * @param override if true, override the existing path generator
     */
    addPath(key, generator, override = false) {
        if (!guardCheck(this) || (!override && this.pathGenerators.has(key))) {
            return false;
        }
        this.pathGenerators.set(key, generator !== null && generator !== void 0 ? generator : defaultPathGenerator);
        return true;
    }
    /**
     * Destroys the current container, invalidating it
     */
    destroy() {
        if (!guardCheck(this)) {
            return;
        }
        this.stop();
        this.particles.destroy();
        this.canvas.destroy();
        for (const [, drawer] of this.drawers) {
            if (drawer.destroy) {
                drawer.destroy(this);
            }
        }
        for (const key of this.drawers.keys()) {
            this.drawers.delete(key);
        }
        __classPrivateFieldGet(this, _Container_engine, "f").plugins.destroy(this);
        this.destroyed = true;
        const mainArr = __classPrivateFieldGet(this, _Container_engine, "f").dom(), idx = mainArr.findIndex((t) => t === this);
        if (idx >= 0) {
            mainArr.splice(idx, 1);
        }
        __classPrivateFieldGet(this, _Container_engine, "f").dispatchEvent("containerDestroyed" /* EventType.containerDestroyed */, { container: this });
    }
    /**
     * Draws a frame
     */
    draw(force) {
        if (!guardCheck(this)) {
            return;
        }
        let refreshTime = force;
        this.drawAnimationFrame = animate()(async (timestamp) => {
            if (refreshTime) {
                this.lastFrameTime = undefined;
                refreshTime = false;
            }
            await this.frameManager.nextFrame(timestamp);
        });
    }
    /**
     * Exports the current configuration using `options` property
     * @returns a JSON string created from `options` property
     */
    exportConfiguration() {
        return JSON.stringify(this.actualOptions, undefined, 2);
    }
    /**
     * Exports the current canvas image, `background` property of `options` won't be rendered because it's css related
     * @param callback The callback to handle the image
     * @param type The exported image type
     * @param quality The exported image quality
     */
    exportImage(callback, type, quality) {
        var _a;
        return (_a = this.canvas.element) === null || _a === void 0 ? void 0 : _a.toBlob(callback, type !== null && type !== void 0 ? type : "image/png", quality);
    }
    /**
     * @deprecated this method is deprecated, please use the exportImage method
     * @param callback The callback to handle the image
     */
    exportImg(callback) {
        this.exportImage(callback);
    }
    /**
     * Gets the animation status
     * @returns `true` is playing, `false` is paused
     */
    getAnimationStatus() {
        return !this.paused && !this.pageHidden && guardCheck(this);
    }
    /**
     * Handles click event in the container
     * @param mode click mode to handle
     */
    handleClickMode(mode) {
        if (!guardCheck(this)) {
            return;
        }
        this.particles.handleClickMode(mode);
        for (const [, plugin] of this.plugins) {
            if (plugin.handleClickMode) {
                plugin.handleClickMode(mode);
            }
        }
    }
    /**
     * Initializes the container
     */
    async init() {
        if (!guardCheck(this)) {
            return;
        }
        const shapes = __classPrivateFieldGet(this, _Container_engine, "f").plugins.getSupportedShapes();
        for (const type of shapes) {
            const drawer = __classPrivateFieldGet(this, _Container_engine, "f").plugins.getShapeDrawer(type);
            if (drawer) {
                this.drawers.set(type, drawer);
            }
        }
        /* options settings */
        __classPrivateFieldSet(this, _Container_options, loadContainerOptions(__classPrivateFieldGet(this, _Container_engine, "f"), this, this._initialSourceOptions, this.sourceOptions), "f");
        this.actualOptions = loadContainerOptions(__classPrivateFieldGet(this, _Container_engine, "f"), this, __classPrivateFieldGet(this, _Container_options, "f"));
        /* init canvas + particles */
        this.retina.init();
        this.canvas.init();
        this.updateActualOptions();
        this.canvas.initBackground();
        this.canvas.resize();
        this.zLayers = this.actualOptions.zLayers;
        this.duration = getRangeValue(this.actualOptions.duration);
        this.lifeTime = 0;
        this.fpsLimit = this.actualOptions.fpsLimit > 0 ? this.actualOptions.fpsLimit : 120;
        const availablePlugins = __classPrivateFieldGet(this, _Container_engine, "f").plugins.getAvailablePlugins(this);
        for (const [id, plugin] of availablePlugins) {
            this.plugins.set(id, plugin);
        }
        for (const [, drawer] of this.drawers) {
            if (drawer.init) {
                await drawer.init(this);
            }
        }
        for (const [, plugin] of this.plugins) {
            if (plugin.init) {
                plugin.init(this.actualOptions);
            }
            else if (plugin.initAsync !== undefined) {
                await plugin.initAsync(this.actualOptions);
            }
        }
        __classPrivateFieldGet(this, _Container_engine, "f").dispatchEvent("containerInit" /* EventType.containerInit */, { container: this });
        this.particles.init();
        this.particles.setDensity();
        for (const [, plugin] of this.plugins) {
            if (plugin.particlesSetup !== undefined) {
                plugin.particlesSetup();
            }
        }
        __classPrivateFieldGet(this, _Container_engine, "f").dispatchEvent("particlesSetup" /* EventType.particlesSetup */, { container: this });
    }
    /**
     * Loads the given theme, overriding the options
     * @param name the theme name, if `undefined` resets the default options or the default theme
     */
    async loadTheme(name) {
        if (!guardCheck(this)) {
            return;
        }
        this.currentTheme = name;
        await this.refresh();
    }
    /**
     * Pauses animations
     */
    pause() {
        if (!guardCheck(this)) {
            return;
        }
        if (this.drawAnimationFrame !== undefined) {
            cancelAnimation()(this.drawAnimationFrame);
            delete this.drawAnimationFrame;
        }
        if (this.paused) {
            return;
        }
        for (const [, plugin] of this.plugins) {
            if (plugin.pause) {
                plugin.pause();
            }
        }
        if (!this.pageHidden) {
            this.paused = true;
        }
        __classPrivateFieldGet(this, _Container_engine, "f").dispatchEvent("containerPaused" /* EventType.containerPaused */, { container: this });
    }
    /**
     * Starts animations and resume from pause
     * @param force
     */
    play(force) {
        if (!guardCheck(this)) {
            return;
        }
        const needsUpdate = this.paused || force;
        if (this.firstStart && !this.actualOptions.autoPlay) {
            this.firstStart = false;
            return;
        }
        if (this.paused) {
            this.paused = false;
        }
        if (needsUpdate) {
            for (const [, plugin] of this.plugins) {
                if (plugin.play) {
                    plugin.play();
                }
            }
        }
        __classPrivateFieldGet(this, _Container_engine, "f").dispatchEvent("containerPlay" /* EventType.containerPlay */, { container: this });
        this.draw(needsUpdate || false);
    }
    /**
     * Restarts the container, just a [[stop]]/[[start]] alias
     */
    async refresh() {
        if (!guardCheck(this)) {
            return;
        }
        /* restart */
        this.stop();
        return this.start();
    }
    async reset() {
        if (!guardCheck(this)) {
            return;
        }
        __classPrivateFieldSet(this, _Container_options, loadContainerOptions(__classPrivateFieldGet(this, _Container_engine, "f"), this), "f");
        return this.refresh();
    }
    /**
     * Customise path generation
     * @deprecated Use the new setPath
     * @param noiseOrGenerator the [[IMovePathGenerator]] object or a function that generates a [[Vector]] object from [[Particle]]
     * @param init the [[IMovePathGenerator]] init function, if the first parameter is a generator function
     * @param update the [[IMovePathGenerator]] update function, if the first parameter is a generator function
     */
    setNoise(noiseOrGenerator, init, update) {
        if (!guardCheck(this)) {
            return;
        }
        this.setPath(noiseOrGenerator, init, update);
    }
    /**
     * Customise path generation
     * @deprecated Use the new addPath
     * @param pathOrGenerator the [[IMovePathGenerator]] object or a function that generates a [[Vector]] object from [[Particle]]
     * @param init the [[IMovePathGenerator]] init function, if the first parameter is a generator function
     * @param update the [[IMovePathGenerator]] update function, if the first parameter is a generator function
     */
    setPath(pathOrGenerator, init, update) {
        if (!pathOrGenerator || !guardCheck(this)) {
            return;
        }
        const pathGenerator = Object.assign({}, defaultPathGenerator);
        if (typeof pathOrGenerator === "function") {
            pathGenerator.generate = pathOrGenerator;
            if (init) {
                pathGenerator.init = init;
            }
            if (update) {
                pathGenerator.update = update;
            }
        }
        else {
            const oldGenerator = pathGenerator;
            pathGenerator.generate = pathOrGenerator.generate || oldGenerator.generate;
            pathGenerator.init = pathOrGenerator.init || oldGenerator.init;
            pathGenerator.update = pathOrGenerator.update || oldGenerator.update;
        }
        this.addPath(defaultPathGeneratorKey, pathGenerator, true);
    }
    /**
     * Starts the container, initializes what are needed to create animations and event handling
     */
    async start() {
        if (this.started || !guardCheck(this)) {
            return;
        }
        await this.init();
        this.started = true;
        __classPrivateFieldGet(this, _Container_eventListeners, "f").addListeners();
        if (this.interactivity.element instanceof HTMLElement && __classPrivateFieldGet(this, _Container_intersectionObserver, "f")) {
            __classPrivateFieldGet(this, _Container_intersectionObserver, "f").observe(this.interactivity.element);
        }
        for (const [, plugin] of this.plugins) {
            if (plugin.startAsync !== undefined) {
                await plugin.startAsync();
            }
            else if (plugin.start !== undefined) {
                plugin.start();
            }
        }
        __classPrivateFieldGet(this, _Container_engine, "f").dispatchEvent("containerStarted" /* EventType.containerStarted */, { container: this });
        this.play();
    }
    /**
     * Stops the container, opposite to `start`. Clears some resources and stops events.
     */
    stop() {
        var _a;
        if (!this.started || !guardCheck(this)) {
            return;
        }
        this.firstStart = true;
        this.started = false;
        __classPrivateFieldGet(this, _Container_eventListeners, "f").removeListeners();
        this.pause();
        this.particles.clear();
        this.canvas.clear();
        if (this.interactivity.element instanceof HTMLElement && __classPrivateFieldGet(this, _Container_intersectionObserver, "f")) {
            __classPrivateFieldGet(this, _Container_intersectionObserver, "f").unobserve(this.interactivity.element);
        }
        for (const [, plugin] of this.plugins) {
            (_a = plugin.stop) === null || _a === void 0 ? void 0 : _a.call(plugin);
        }
        for (const key of this.plugins.keys()) {
            this.plugins.delete(key);
        }
        __classPrivateFieldSet(this, _Container_sourceOptions, __classPrivateFieldGet(this, _Container_options, "f"), "f");
        __classPrivateFieldGet(this, _Container_engine, "f").dispatchEvent("containerStopped" /* EventType.containerStopped */, { container: this });
    }
    /**
     * Updates the container options
     */
    updateActualOptions() {
        this.actualOptions.responsive = [];
        const newMaxWidth = this.actualOptions.setResponsive(this.canvas.size.width, this.retina.pixelRatio, __classPrivateFieldGet(this, _Container_options, "f"));
        this.actualOptions.setTheme(this.currentTheme);
        if (this.responsiveMaxWidth != newMaxWidth) {
            this.responsiveMaxWidth = newMaxWidth;
            return true;
        }
        return false;
    }
    intersectionManager(entries) {
        if (!this.actualOptions.pauseOnOutsideViewport) {
            return;
        }
        for (const entry of entries) {
            if (entry.target !== this.interactivity.element) {
                continue;
            }
            (entry.isIntersecting ? this.play : this.pause)();
        }
    }
}
_Container_engine = new WeakMap(), _Container_eventListeners = new WeakMap(), _Container_intersectionObserver = new WeakMap(), _Container_options = new WeakMap(), _Container_sourceOptions = new WeakMap();
